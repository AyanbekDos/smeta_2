Ты — элитный Python-разработчик, специализирующийся на создании комплексных автоматизированных систем. Твоя задача — сгенерировать единый, полный и хорошо прокомментированный Python-скрипт для Telegram-бота. Скрипт должен в точности реализовать следующий пайплайн обработки документов.

ТЕХНИЧЕСКОЕ ЗАДАНИЕ

1. Общие требования и Стек:

    Основная библиотека: python-telegram-bot версии 20.0 или выше (с использованием asyncio).
    Зависимости: google-generativeai, azure-ai-documentintelligence, pypdf, pandas, Pillow, python-dotenv.
    Ключевое ограничение: Для конвертации PDF в изображение не использовать внешние бинарные зависимости, такие как poppler. Предпочтительный метод — связка pypdf и Pillow, либо, как надежный запасной вариант, PyMuPDF (fitz).
    Конфигурация: Все ключи и эндпоинты должны загружаться из файла .env при старте скрипта: TELEGRAM_BOT_TOKEN, GEMINI_API_KEY, AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT, AZURE_DOCUMENT_INTELLIGENCE_KEY.
    Архитектура: Вся логика диалога с пользователем должна быть построена с использованием ConversationHandler из python-telegram-bot.
Создай venv и работай через него
2. Логика работы (Workflow), реализованная в ConversationHandler:

Состояния диалога:
SELECTING_ACTION -> AWAITING_CONFIRMATION -> AWAITING_MANUAL_PAGE

Шаг 1: Инициализация и точка входа

    Триггер: Команда /start.
    Действие:
        Создай обработчик CommandHandler('start', start_command). Это будет entry_point для ConversationHandler.
        Функция start_command должна отправить пользователю приветственное сообщение: "Здравствуйте! Я помогу вам обработать спецификацию из PDF-файла проекта марки 'КМ'. Пожалуйста, загрузите ваш PDF-файл."
        Функция должна вернуть состояние SELECTING_ACTION, в котором бот будет ожидать загрузки файла.

Шаг 2: Прием и валидация PDF-файла

    Триггер: Пользователь отправляет документ в чат.
    Действие:
        В состоянии SELECTING_ACTION создай обработчик MessageHandler(filters.Document.PDF, handle_document).
        Функция handle_document выполняет следующее:
        a. Получает объект файла (document) и его имя (file_name).
        b. Валидация 1 (Имя файла): Проверяет, содержится ли в file_name подстрока "КМД" без учета регистра.
        c. Скачивает файл в байтовый поток io.BytesIO. Это важно, чтобы не создавать лишних файлов на диске на этом этапе.
        d. Валидация 2 (Содержимое): Используя pypdf.PdfReader, открывает PDF из байтового потока, извлекает текст с первой страницы (page.extract_text()) и ищет в нем точное совпадение со строкой "КМД".
        e. Результат валидации: Если хотя бы одна из проверок нашла "КМД", бот отправляет сообщение: "Ошибка: Этот бот не работает с чертежами марки КМД. Пожалуйста, загрузите файл проекта марки КМ." и завершает диалог (return ConversationHandler.END).
        f. Если валидация пройдена, бот отправляет сообщение: "Файл принят. Идет поиск таблицы спецификации..." и переходит к следующему шагу.

Шаг 3: Поиск номера страницы с помощью Gemini Flash

    Триггер: Успешная валидация на предыдущем шаге.
    Действие (продолжается в handle_document):
        Сохрани PDF из байтового потока во временный файл на диске (например, temp_{user_id}.pdf).
        Используя google.generativeai, загрузи этот файл в API (genai.upload_file).
        Сформируй промт, используя текст из файла C:\Users\imort\smeta 2\find_table.txt.
        Отправь запрос к модели gemini-1.5-flash-latest, передав ей загруженный файл и промт.
        Удали временный PDF-файл с диска сразу после загрузки в API.
        Обработай ответ: попытайся преобразовать его в целое число. Если не удается, отправь сообщение "Не удалось автоматически определить номер страницы. Пожалуйста, попробуйте другой документ." и заверши диалог (return ConversationHandler.END).

Шаг 4: Цикл подтверждения страницы пользователем

    Триггер: Получен номер страницы от Gemini.
    Действие (продолжается в handle_document):
        Используя pypdf и номер страницы (не забудь про коррекцию page_number - 1 для индексации), извлеки нужную страницу из PDF-файла (который все еще находится в байтовом потоке).
        Сконвертируй эту страницу в изображение PNG и сохрани результат в новый байтовый поток io.BytesIO.
        Создай инлайн-клавиатуру InlineKeyboardMarkup с двумя кнопками:
            ✅ Да, всё верно с callback_data='page_confirm_yes'.
            ❌ Нет, указать другую с callback_data='page_confirm_no'.
        Отправь пользователю PNG-изображение с подписью "Это верная таблица для расчета сметы?" и прикрепленной клавиатурой.
        Сохрани байты PDF и номер найденной страницы в context.user_data, чтобы иметь к ним доступ на следующих шагах.
        Функция должна вернуть состояние AWAITING_CONFIRMATION.

Шаг 5: Обработка выбора пользователя

    Триггер: Пользователь нажимает инлайн-кнопку.
    Действие:
        В состоянии AWAITING_CONFIRMATION создай обработчик CallbackQueryHandler(handle_confirmation_choice).
        Функция handle_confirmation_choice делает следующее:
        a. Если callback_data == 'page_confirm_yes':
        * Отвечает на колбэк и редактирует сообщение, убирая клавиатуру и изменяя текст на "Отлично! Начинаю распознавание и структурирование данных. Это может занять несколько минут...".
        * Вызывает основную функцию обработки (Шаг 6).
        * После завершения обработки возвращает ConversationHandler.END.
        b. Если callback_data == 'page_confirm_no':
        * Редактирует сообщение, изменяя текст на "Пожалуйста, введите правильный номер страницы.".
        * Возвращает состояние AWAITING_MANUAL_PAGE.

Шаг 5.1: Обработка ручного ввода номера страницы

    Триггер: Пользователь отправляет текстовое сообщение после нажатия "Нет".
    Действие:
        В состоянии AWAITING_MANUAL_PAGE создай обработчик MessageHandler(filters.TEXT & ~filters.COMMAND, handle_manual_page_input).
        Функция handle_manual_page_input делает следующее:
        a. Проверяет, является ли введенный текст числом. Если нет, отправляет сообщение "Пожалуйста, введите корректный номер страницы в виде числа." и остается в том же состоянии (return AWAITING_MANUAL_PAGE).
        b. Если это число, обновляет номер страницы в context.user_data.
        c. Отправляет сообщение "Принято. Начинаю распознавание и структурирование данных со страницы [номер]. Это может занять несколько минут...".
        d. Вызывает основную функцию обработки (Шаг 6).
        e. Возвращает ConversationHandler.END.

Шаг 6: Распознавание (Azure) и Структурирование (Gemini Pro)

    Триггер: Номер страницы подтвержден (автоматически или вручную).
    Действие (реализуй это в отдельной асинхронной функции, вызываемой из обработчиков):
        Из context.user_data извлеки байты PDF и подтвержденный номер страницы.
        Сконвертируй нужную страницу в PNG (как на Шаге 4).
        Azure OCR: Отправь байты PNG-изображения в Azure Document Intelligence API (модель "prebuilt-read"). Дождись результата и извлеки все текстовое содержимое (result.content).
        Gemini Structuring: Сформируй промт, используя текст из файла C:\Users\imort\smeta 2\2_extract_details.txt, подставив в него {AZURE_OCR_TEXT}.
        Отправь этот промт к модели gemini-1.5-pro-latest, настроив ее на вывод ответа в формате JSON.
        Получи от Gemini JSON-строку.

Шаг 7: Обработка JSON и генерация отчетов

    Триггер: Получена JSON-строка от Gemini.
    Действие (продолжение предыдущей функции):
        Распарси JSON-строку в объект Python.
        Реализуй рекурсивную функцию "сплющивания" JSON. Она должна обходить вложенную структуру и для каждой конечной записи с ключом "масса" создавать плоский словарь, собирая все "родительские" ключи. Итоговая плоская структура должна содержать столбцы: Наименование профиля, Марка стали, Размер профиля, Тип элемента, Позиции, Масса, т.
        Создай pandas.DataFrame из полученного списка "сплющенных" словарей.
        Генерация Excel: Сохрани DataFrame в .xlsx файл в байтовый поток io.BytesIO.
        Генерация Текста: Извлеки "единица_измерения" из исходного JSON. Создай текстовую строку, начинающуюся с f"Единица измерения: {unit}", добавь в нее таблицу из DataFrame (df.to_string()), и сохрани результат в байтовый поток io.BytesIO.

Шаг 8: Отправка результатов пользователю

    Триггер: Файлы отчетов сгенерированы в байтовые потоки.
    Действие (финальная часть функции обработки):
        Отправь пользователю сообщение, содержащее первые 3000 символов текстового отчета для предпросмотра.
        Отправь сгенерированный .xlsx файл как документ.
        Отправь сгенерированный .txt файл как документ.
        Отправь финальное сообщение: "Готово! Спецификация обработана. Файлы для скачивания выше."

3. Структура main:

    Создай Application.
    Собери ConversationHandler со всеми entry_points, states и fallbacks.
    Добавь ConversationHandler в Application.
    Запусти бота через application.run_polling().
